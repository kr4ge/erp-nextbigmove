import { Injectable, NotFoundException, ForbiddenException, BadRequestException, Logger } from '@nestjs/common';
import { InjectQueue } from '@nestjs/bull';
import { Queue } from 'bull';
import { ClsService } from 'nestjs-cls';
import { PrismaService } from '../../common/prisma/prisma.service';
import {
  CreateWorkflowDto,
  UpdateWorkflowDto,
  WorkflowResponseDto,
  WorkflowExecutionResponseDto,
} from './dto';
import { WorkflowTriggerType, WorkflowExecutionStatus } from '@prisma/client';
import * as cronParser from 'cron-parser';
import { WORKFLOW_QUEUE, WorkflowJobData } from './processors/workflow.processor';
import { DateRangeService } from './services/date-range.service';
import { WorkflowProcessorService } from './services/workflow-processor.service';

@Injectable()
export class WorkflowService {
  private readonly logger = new Logger(WorkflowService.name);
  // WorkflowSchedulerService will be injected lazily to avoid circular dependency
  private schedulerService: any;

  constructor(
    private readonly prisma: PrismaService,
    private readonly cls: ClsService,
    private readonly dateRangeService: DateRangeService,
    private readonly workflowProcessor: WorkflowProcessorService,
    @InjectQueue(WORKFLOW_QUEUE) private readonly workflowQueue: Queue<WorkflowJobData>,
  ) {}

  // Lazy inject scheduler service to avoid circular dependency
  setSchedulerService(schedulerService: any) {
    this.schedulerService = schedulerService;
  }

  /**
   * Create a new workflow for the current tenant
   */
  async create(createWorkflowDto: CreateWorkflowDto): Promise<WorkflowResponseDto> {
    const tenantId = this.cls.get('tenantId');
    const teamId = this.cls.get('teamId');
    const userId = this.cls.get('userId');
    const role = this.cls.get('userRole');
    const isLegacyAdmin = role === 'ADMIN' || role === 'SUPER_ADMIN';
    if (!tenantId) {
      throw new ForbiddenException('Tenant context is required');
    }

    // Check if user has tenant-wide admin access via dynamic roles
    let hasTenantWideAccess = false;
    if (!isLegacyAdmin && userId) {
      hasTenantWideAccess = await this.checkTenantWideAccess(userId, tenantId);
    }

    const isAdmin = isLegacyAdmin || hasTenantWideAccess;

    const { name, description, schedule, config, teamId: payloadTeamId } = createWorkflowDto;

    if (!teamId && !payloadTeamId && !isAdmin) {
      throw new ForbiddenException('Team context is required');
    }

    if (payloadTeamId && teamId && payloadTeamId !== teamId) {
      throw new ForbiddenException('Team mismatch between context and payload');
    }
    const effectiveTeamId = payloadTeamId || teamId || null;

    // Validate cron expression if schedule is provided
    if (schedule) {
      try {
        cronParser.parseExpression(schedule);
      } catch (error) {
        throw new BadRequestException('Invalid cron expression format');
      }
    }

    // Create workflow
    const workflow = await this.prisma.workflow.create({
      data: {
        name,
        description,
        schedule,
        config: config ? (config as any) : {},
        tenantId,
        teamId: effectiveTeamId,
        enabled: true,
      },
    });

    // Register cron job if schedule is provided
    if (schedule && this.schedulerService) {
      await this.schedulerService.registerWorkflowCron(workflow.id, schedule);
    }

    return new WorkflowResponseDto(workflow);
  }

  /**
   * Get all workflows for the current tenant
   */
  async findAll(): Promise<WorkflowResponseDto[]> {
    const tenantId = this.cls.get('tenantId');
    const teamId = this.cls.get('teamId');
    const userId = this.cls.get('userId');
    const role = this.cls.get('userRole');
    const isLegacyAdmin = role === 'ADMIN' || role === 'SUPER_ADMIN';
    if (!tenantId) {
      throw new ForbiddenException('Tenant context is required');
    }

    // Check if user has tenant-wide admin access via dynamic roles
    let hasTenantWideAccess = false;
    if (!isLegacyAdmin && userId) {
      hasTenantWideAccess = await this.checkTenantWideAccess(userId, tenantId);
    }

    const isAdmin = isLegacyAdmin || hasTenantWideAccess;

    const workflows = await this.prisma.workflow.findMany({
      where: { tenantId, ...(isAdmin ? {} : teamId ? { teamId } : { teamId: null }) },
      orderBy: { createdAt: 'desc' },
    });

    return workflows.map((workflow) => new WorkflowResponseDto(workflow));
  }

  /**
   * Get a single workflow by ID
   */
  async findOne(id: string): Promise<WorkflowResponseDto> {
    const tenantId = this.cls.get('tenantId');
    const teamId = this.cls.get('teamId');
    const role = this.cls.get('userRole');
    const isAdmin = role === 'ADMIN' || role === 'SUPER_ADMIN';
    if (!tenantId) {
      throw new ForbiddenException('Tenant context is required');
    }

    const workflow = await this.prisma.workflow.findFirst({
      where: {
        id,
        tenantId,
        ...(teamId ? { teamId } : isAdmin ? {} : { teamId }),
      },
    });

    if (!workflow) {
      throw new NotFoundException(`Workflow with ID ${id} not found`);
    }

    return new WorkflowResponseDto(workflow);
  }

  /**
   * Update a workflow
   */
  async update(id: string, updateWorkflowDto: UpdateWorkflowDto): Promise<WorkflowResponseDto> {
    const tenantId = this.cls.get('tenantId');
    const teamId = this.cls.get('teamId');
    const role = this.cls.get('userRole');
    const isAdmin = role === 'ADMIN' || role === 'SUPER_ADMIN';
    if (!tenantId) {
      throw new ForbiddenException('Tenant context is required');
    }
    if (!teamId && !isAdmin) {
      throw new ForbiddenException('Team context is required');
    }

    // Verify workflow exists and belongs to tenant
    const existingWorkflow = await this.prisma.workflow.findFirst({
      where: {
        id,
        tenantId,
        ...(teamId ? { teamId } : isAdmin ? {} : { teamId }),
      },
    });

    if (!existingWorkflow) {
      throw new NotFoundException(`Workflow with ID ${id} not found`);
    }

    const { name, description, schedule, config, enabled, teamId: payloadTeamId } = updateWorkflowDto;

    if (payloadTeamId && teamId && payloadTeamId !== teamId) {
      throw new ForbiddenException('Team mismatch between context and payload');
    }
    if (!payloadTeamId && !teamId && !isAdmin) {
      throw new ForbiddenException('Team context is required');
    }

    // Validate cron expression if schedule is being updated
    if (schedule) {
      try {
        cronParser.parseExpression(schedule);
      } catch (error) {
        throw new BadRequestException('Invalid cron expression format');
      }
    }

    // Prepare update data
    const updateData: any = {};
    if (name !== undefined) updateData.name = name;
    if (description !== undefined) updateData.description = description;
    if (schedule !== undefined) updateData.schedule = schedule;
    if (config !== undefined) updateData.config = config;
    if (enabled !== undefined) updateData.enabled = enabled;

    // Update workflow
    const updatedWorkflow = await this.prisma.workflow.update({
      where: { id },
      data: updateData,
    });

    return new WorkflowResponseDto(updatedWorkflow);
  }

  /**
   * Delete a workflow
   */
  async remove(id: string): Promise<void> {
    const tenantId = this.cls.get('tenantId');
    const teamId = this.cls.get('teamId');
    const role = this.cls.get('userRole');
    const isAdmin = role === 'ADMIN' || role === 'SUPER_ADMIN';
    if (!tenantId) {
      throw new ForbiddenException('Tenant context is required');
    }

    // Verify workflow exists and belongs to tenant
    const workflow = await this.prisma.workflow.findFirst({
      where: {
        id,
        tenantId,
        ...(teamId ? { teamId } : isAdmin ? {} : { teamId }),
      },
    });

    if (!workflow) {
      throw new NotFoundException(`Workflow with ID ${id} not found`);
    }

    // Delete workflow (cascade will delete executions)
    await this.prisma.workflow.delete({
      where: { id },
    });
  }

  /**
   * Enable a workflow
   */
  async enable(id: string): Promise<WorkflowResponseDto> {
    const tenantId = this.cls.get('tenantId');
    const teamId = this.cls.get('teamId');
    const role = this.cls.get('userRole');
    const isAdmin = role === 'ADMIN' || role === 'SUPER_ADMIN';
    if (!tenantId) {
      throw new ForbiddenException('Tenant context is required');
    }

    const workflow = await this.prisma.workflow.findFirst({
      where: {
        id,
        tenantId,
        ...(teamId ? { teamId } : isAdmin ? {} : { teamId }),
      },
    });

    if (!workflow) {
      throw new NotFoundException(`Workflow with ID ${id} not found`);
    }

    const updatedWorkflow = await this.prisma.workflow.update({
      where: { id },
      data: { enabled: true },
    });

    return new WorkflowResponseDto(updatedWorkflow);
  }

  /**
   * Disable a workflow
   */
  async disable(id: string): Promise<WorkflowResponseDto> {
    const tenantId = this.cls.get('tenantId');
    const teamId = this.cls.get('teamId');
    const role = this.cls.get('userRole');
    const isAdmin = role === 'ADMIN' || role === 'SUPER_ADMIN';
    if (!tenantId) {
      throw new ForbiddenException('Tenant context is required');
    }

    const workflow = await this.prisma.workflow.findFirst({
      where: {
        id,
        tenantId,
        ...(teamId ? { teamId } : isAdmin ? {} : { teamId }),
      },
    });

    if (!workflow) {
      throw new NotFoundException(`Workflow with ID ${id} not found`);
    }

    const updatedWorkflow = await this.prisma.workflow.update({
      where: { id },
      data: { enabled: false },
    });

    return new WorkflowResponseDto(updatedWorkflow);
  }

  /**
   * Get all executions for a workflow
   */
  async getExecutions(workflowId: string): Promise<WorkflowExecutionResponseDto[]> {
    const tenantId = this.cls.get('tenantId');
    const teamId = this.cls.get('teamId');
    const role = this.cls.get('userRole');
    const isAdmin = role === 'ADMIN' || role === 'SUPER_ADMIN';
    if (!tenantId) {
      throw new ForbiddenException('Tenant context is required');
    }

    // Verify workflow exists and belongs to tenant
    const workflow = await this.prisma.workflow.findFirst({
      where: {
        id: workflowId,
        tenantId,
        ...(teamId ? { teamId } : isAdmin ? {} : { teamId }),
      },
    });

    if (!workflow) {
      throw new NotFoundException(`Workflow with ID ${workflowId} not found`);
    }

    const executions = await this.prisma.workflowExecution.findMany({
      where: {
        workflowId,
        tenantId,
        ...(teamId ? { teamId } : isAdmin ? {} : { teamId }),
      },
      orderBy: { createdAt: 'desc' },
    });

    return executions.map((execution) => new WorkflowExecutionResponseDto(execution));
  }

  /**
   * Get a single execution by ID
   */
  async getExecution(executionId: string): Promise<WorkflowExecutionResponseDto> {
    const tenantId = this.cls.get('tenantId');
    const teamId = this.cls.get('teamId');
    const role = this.cls.get('userRole');
    const isAdmin = role === 'ADMIN' || role === 'SUPER_ADMIN';
    if (!tenantId) {
      throw new ForbiddenException('Tenant context is required');
    }

    const execution = await this.prisma.workflowExecution.findFirst({
      where: {
        id: executionId,
        tenantId,
        ...(teamId ? { teamId } : isAdmin ? {} : { teamId }),
      },
    });

    if (!execution) {
      throw new NotFoundException(`Workflow execution with ID ${executionId} not found`);
    }

    return new WorkflowExecutionResponseDto(execution);
  }

  /**
   * Manually trigger a workflow execution
   * Returns the created execution record
   */
  async triggerManual(
    workflowId: string,
    dateRangeSince?: string,
    dateRangeUntil?: string,
  ): Promise<WorkflowExecutionResponseDto> {
    const tenantId = this.cls.get('tenantId');
    const teamId = this.cls.get('teamId');
    const role = this.cls.get('userRole');
    const isAdmin = role === 'ADMIN' || role === 'SUPER_ADMIN';
    if (!tenantId) {
      throw new ForbiddenException('Tenant context is required');
    }
    if (!teamId && !isAdmin) {
      throw new ForbiddenException('Team context is required');
    }

    // Verify workflow exists and belongs to tenant
    const workflow = await this.prisma.workflow.findFirst({
      where: {
        id: workflowId,
        tenantId,
        ...(teamId ? { teamId } : isAdmin ? {} : { teamId }),
      },
    });

    if (!workflow) {
      throw new NotFoundException(`Workflow with ID ${workflowId} not found`);
    }

    if (!workflow.enabled) {
      throw new BadRequestException('Cannot trigger a disabled workflow');
    }

    // Calculate date range if not provided
    let since = dateRangeSince;
    let until = dateRangeUntil;

    if (!since || !until) {
      const config = workflow.config as any;
      // Prefer workflow-level date range; fall back to legacy per-source config
      const dateRangeConfig =
        config.dateRange ||
        config.sources?.meta?.dateRange ||
        config.sources?.pos?.dateRange;

      if (!dateRangeConfig) {
        throw new BadRequestException('No date range configured for workflow');
      }

      const calculatedRange = this.dateRangeService.calculateDateRange(dateRangeConfig);
      since = calculatedRange.since;
      until = calculatedRange.until;
    }

    // Create execution record
    const execution = await this.prisma.workflowExecution.create({
      data: {
        workflowId,
        tenantId,
        teamId: teamId || null,
        triggerType: WorkflowTriggerType.MANUAL,
        status: WorkflowExecutionStatus.PENDING,
        dateRangeSince: since,
        dateRangeUntil: until,
      },
    });

    // Enqueue Bull job to process this execution (or inline fallback)
    const inlinePreferred =
      process.env.WORKFLOW_PROCESS_INLINE === 'true' ||
      process.env.NODE_ENV === 'development';

    let enqueued = false;

    if (!inlinePreferred) {
      try {
        await this.workflowQueue.add({
          executionId: execution.id,
          tenantId,
          workflowId,
        });
        enqueued = true;
      } catch (error) {
        this.logger.warn(
          `Queue enqueue failed for execution ${execution.id}, falling back to inline processing: ${error?.message}`,
        );
      }
    }

    if (!enqueued) {
      this.runExecutionInline(execution.id);
    }

    return new WorkflowExecutionResponseDto(execution);
  }

  /**
   * Cancel a running workflow execution
   */
  async cancelExecution(executionId: string): Promise<WorkflowExecutionResponseDto> {
    const tenantId = this.cls.get('tenantId');
    if (!tenantId) {
      throw new ForbiddenException('Tenant context is required');
    }

    const execution = await this.prisma.workflowExecution.findFirst({
      where: {
        id: executionId,
        tenantId,
      },
    });

    if (!execution) {
      throw new NotFoundException(`Workflow execution with ID ${executionId} not found`);
    }

    if (execution.status !== WorkflowExecutionStatus.RUNNING && execution.status !== WorkflowExecutionStatus.PENDING) {
      throw new BadRequestException('Can only cancel PENDING or RUNNING executions');
    }

    const updatedExecution = await this.prisma.workflowExecution.update({
      where: { id: executionId },
      data: {
        status: WorkflowExecutionStatus.CANCELLED,
        completedAt: new Date(),
        duration: execution.startedAt
          ? new Date().getTime() - execution.startedAt.getTime()
          : 0,
      },
    });

    // Note: Bull jobs will check execution status before processing
    // If status is CANCELLED, the processor will skip execution

    return new WorkflowExecutionResponseDto(updatedExecution);
  }

  /**
   * Inline processor fallback (when queue is disabled/unavailable)
   * Fire-and-forget to keep API response fast.
   */
  private runExecutionInline(executionId: string) {
    setImmediate(async () => {
      try {
        await this.workflowProcessor.processWorkflowExecution(executionId);
      } catch (error) {
        this.logger.error(
          `Inline workflow execution ${executionId} failed: ${error?.message}`,
          error?.stack,
        );
        // Mark execution as failed to avoid stuck PENDING state
        await this.prisma.workflowExecution.update({
          where: { id: executionId },
          data: {
            status: WorkflowExecutionStatus.FAILED,
            completedAt: new Date(),
            errors: [
              {
                date: 'N/A',
                source: 'system',
                error: error?.message || 'Inline execution failed',
              },
            ],
          },
        });
      }
    });
  }

  /**
   * Check if user has tenant-wide admin access via dynamic roles
   */
  private async checkTenantWideAccess(userId: string, tenantId: string): Promise<boolean> {
    const adminPermKeys = new Set(['team.manage', 'permission.assign', 'user.manage']);

    const assignments = await this.prisma.userRoleAssignment.findMany({
      where: { userId, tenantId, teamId: null },
      include: {
        role: {
          include: {
            rolePermissions: {
              include: { permission: true },
            },
          },
        },
      },
    });

    for (const a of assignments) {
      for (const rp of a.role.rolePermissions) {
        if (adminPermKeys.has(rp.permission.key)) {
          return true;
        }
      }
    }

    return false;
  }
}
